#!/usr/bin/env ruby

# Author: Patrick Helm (deradon87@gmail.com), 2013
# Forked by Mario Uher https://gist.github.com/haihappen/4995672
#
#
# Simple git-snippet to commit a small fix with auto-generated commit-message.
#
# ## Description
#
#   I noticed, we developers often needs to fix a small typo or do something
#   similiar. And I noticed a lot of Devs, will create awful, or no
#   commit-message at all for these little changes.
#
#   So, this little script here, will automatically add files to your index,
#   shows you the generated commit-message and commit if you are fine.
#
#   Or you just abort, because you got a idea of a great message!
#
#
# ## Usage
#
#   git-fix
#
#
# ## Installation
#
#   Save file to ~/bin/git-fix (may chmod +X it)
#
#
# ## Example
#
# $ git-fix
# > git commit -m 'Fixes: Gemfile, Gemfile.lock
#
#   Other files:
#
#   * application_tab_edit_810.css.scss
#   * errbit.rb
#   * item_wrapper.rb
#   * manager_app_helper.rb
#   * package.rb
#   * routes.rb
#   * schema.rb
#   * tab_app.rb
#   * tabs_controller.rb'


# It'a bird. It'a plane. No, it's a GitFix!
class GitFix
  # Used to get name out of 'git status'
  NAME_REGEX = /[^\/]*$/

  # Run a GitFix
  def initialize
    warn("[WARNING] No files to commit found! --- Aborting! ---") and exit if files.empty?
    preview_commit
    git_add
    git_commit
  end

  def preview_commit
    puts "git commit -m '#{commit_message}'\n\n[INFO] Press Enter to continue (ctrl+c to abort)"
    gets
  end

  def git_add
    files.each { |f| run("git add #{f}") }
  end

  def git_commit
    run "git commit -m '#{commit_message}'"
  end

  # Compose and return the commit message
  def commit_message
    @commit_message ||= begin
      files = self.file_names
      files_for_summary = []

      files_for_summary << files.shift while valid_summary_for?([*files_for_summary, files.first]) && !files.empty?
      message = message_summary.call(files_for_summary)

      unless files.empty?
        message << "\n\nOther files:\n"
        message << files.map { |f| "\n* #{f}" }.join
      end

      message
    end
  end

  # Returns: An array containing files to add to stage
  def files
    @files ||= `#{files_cmd}`.split("\n")
  end

  def file_names
    @file_names ||= files.map { |f| f[NAME_REGEX] }.sort
  end

private
  def valid_summary_for?(files)
    message_summary.call(files).length <= 52
  end

  def message_summary
    @message_summary ||= Proc.new { |files| "Fixes: #{files.join(', ')}" }
  end

  # Simple helper to run a shell command
  def run(cmd, options = {:show => true})
    puts "[CMD] #{cmd}"
    r = `#{cmd}`
    puts r if options[:show] && !r.empty?
  end

  def files_cmd
    <<-FILES_CMF
      git status |
      ack "modified:\s+(.*)$" |
      sed 's/^#[[:space:]]*modified:[[:space:]]*\\(.*\\)$/\\1/g'
    FILES_CMF
  end
end

# Run GitFix
GitFix.new